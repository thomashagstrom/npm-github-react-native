# Writing tests

- [Integration tests](#integration-tests)
- [Writing Unit tests](#writing-unit-tests)
- [Writing component tests](#writing-component-tests)
- [Fire events](#fire-events)
- [Testing hooks](#testing-hooks)
- [Writing mocks](#writing-mocks)

<small><i><a href='http://ecotrust-canada.github.io/markdown-toc/'>Table of contents generated with markdown-toc</a></i></small>

## Integration tests

This documentation covers writing unit tests for components. You could perform e2e integration tests using for example [Detox](https://github.com/wix/Detox).

See main _[README.md](./README.md##jest)_ for running tests.

## Writing Unit tests

The [Jest testing framework](https://jestjs.io/docs/getting-started) is used to execute unit tests. It's very versitile and together with some additinal libs we'll look at here it will allow you to test functions, context, hooks, components and types.

As a very basic example this class that has some simple utility functions.

```typescript
import format from 'date-fns/format';

export const getDateString = (date?: Date | number): string =>
  formatDate(date, 'yyyy-MM-dd');

export const getTimeString = (date?: Date | number): string =>
  formatDate(date, 'HH:mm');

type MockableDate = {unixms: number};

export const formatDate = (
  dateTimeUtc?: MockableDate | Date | number,
  dateFormat = 'HH:mm',
) => {
  if (!dateTimeUtc) return '';

  const dateTime = dateTimeUtc as unknown as MockableDate;

  return format(
    dateTime.unixms ||
      (dateTime as unknown as number) ||
      (dateTime as unknown as Date),
    dateFormat,
  );
};
```

To test this, we've first created a _**tests**_ folder in level with the file.

In it, we then add a test matching the file, but suffixed `.test.ts` / `.test.tsx`.

Here's a dateformat test:

```typescript
import {getDateString, getTimeString} from '../dateFormat';

describe('utils', () => {
  describe('getDateString', () => {
    it('when `1634207075756` returns `2021-10-14`', () => {
      const d = getDateString(1634207075756);
      expect(d).toBe('2021-10-14');
    });

    it('when `1634207075756` returns `12:24`', () => {
      const d = getTimeString(1634207075756);
      expect(d).toBe('12:24');
    });
  });
});
```

You see it imports the dateFormat file at the top. It then uses jest `describe` blocks to group (e.g. by feature and file) the test, which helps create a neat structure in the test report generated by CI.

The `it` block (or `test`) tests one single [test scenario](https://www.guru99.com/test-scenario.html). E.G "when this value result should be this".

The jest function `expect` takes in an object - the result - and then use [test matchers](https://jestjs.io/docs/using-matchers) to evaluate the result.

## Writing component tests

When testing components we want to mount them as if they were on a device without having to do a click test. This is possible using Jest + [**React Testing Library**](https://testing-library.com/docs/react-native-testing-library/intro/). This gives us a lot of power to unit test every aspect of our components using props, clicks and state without having to start a simulator!

Read the above description about unit tests first to get the basics.

In this example we're looking at how [the test](./src/features/login/__tests__/LoginForm.test.tsx) for the [`LoginForm`](./src/features/login/LoginForm.tsx) component was written.

Similar to the unit test above, create a `__tests__` folder in the feature directory (in level with the component).

In the test folder, create a file with the syntax [component]_.test.tsx_, e.g. `LoginForm/__tests__/LoginForm.test.tsx`. This will be picked up by the test runner.

To test a React-Native component (we leave React rendering to Storybook and cypress), use the RN specific import of the testing library:

```typescript
import {render} from '@testing-library/react-native';
import React from 'react';
```

Add resonable `describe` blocks (no more than two levels) to make the test report pretty:

```typescript
describe('components', () => {
  describe('LoginForm', () => {});
});
```

Now look at your existing or future component. What is your [test scenario](https://www.guru99.com/test-scenario.html)? Maybe you want to check that the UX guidelines are implemented properly, the children render or touches have the desired effect?

E.G "When [parameter] is `true` [property] should be [value]".

Never test two scenarios in the same test as it's unreliable. Rather write more tests for the same component (until you get 100 % test coverage).

Usually you want to inspect or manipulate a child element in the component. Assign it a [testID and data-cy](#test-id-and-data-cy) and use [test-library queries](https://testing-library.com/docs/queries/about) to get the rendered element.

```typescript
export const LoginForm: React.FC<LoginFormProps> = ({
  children,
  onLogin,
  mode,
  compact,
}) => {
  return (
    <View>
      <Text>LoginForm</Text>
      <Button
        onPress={onLogin}
        accessibilityLabel="Login"
        mode={mode}
        compact={compact}>
        {children || 'Login'}
      </Button>
    </View>
  );
};
```

In our test we search for a specific text element using [`findByText`](https://testing-library.com/docs/example-findbytext/) query. Notice how the query class is returned by `render`, not imported as in other testing libraries.

```typescript
test('Should have LoginForm title', () => {
      const {findByText} = render(<LoginForm onLogin={jest.fn()} />);
      expect(findByText('LoginForm')).toBeDefined();
    });
```

We have now (shallow) rendered the component (if found) and can inspec it's `children` and `props`.

As with the unit test, we use logical [test matchers](https://jestjs.io/docs/using-matchers) to evaluate the rendered component.

## Fire events

You can also fire events like `onPress` etc using the [`fireEvent`](https://callstack.github.io/react-native-testing-library/docs/api#fireevent) import. Notice that this is a import, not something returned by `render`. In this example we test that the function is called with specific props that we pass to the click handler.

```typescript
import { fireEvent, render } from '@testing-library/react-native';

const TEST_BTN = 'button';

describe('components', () => {
  describe('Button', () => {
    test('handleClick should be called', () => {
      let setResult = jest.fn();
      const { getByTestId } = render(
        <Button handleClick={setResult} width="auto" />,
      );

      const comp = getByTestId(TEST_BTN);
      const props = { stopPropagation: jest.fn() };

      fireEvent(comp, 'onClick', props);
      expect(setResult).toHaveBeenCalledWith(props);
    });
  ...
```

## Testing hooks

You can even test hook lifecycle using [@testing-library/react-hooks](https://github.com/testing-library/react-hooks-testing-library).

## Writing mocks

In general we want to test everything, but that said we do not want to test other peoples code. And in the react-native scenario any native code will break the test so we have to mock away that lib and simulate the result.

Native and untyped libraries tend to confuse Jest. To get around this we can create a file in the [`__mocks__`](./__mocks__) folder. E.G _**mocks**/react-native-date-picker/index.js_:

```javascript
module.exports = {
  // Exports go here
};
```

The mock contains a module export that represents the library. Look at whatever you are importing in your code and put that exact name in the export.

So say we're importing an external component:

```typescript
import {Button} from 'react-native-paper';
```

We create the matching path in mocks as seen above and put the export in to the module:

```javascript
// __mocks__/react-native-paper.js
module.exports = {
  Button: 'View',
  // other exports
};
```

Why did we write "View" as a string? This has to do with the testing library. Any primitive component you put in here will be rendered as that component in the test, in this case a RN `View`.

You can mock a function by assigning the export to `jest.fn()`:

```javascript
module.exports = {
  keyboard: {
    dismiss: jest.fn(),
  },
};
```

To create reliable tests we often mock the return value properly:

```javascript
module.exports = {
  getDimensions: () => ({width: 100, height: 200}),
};
```

Default export is also supported by declaring `__esModule` and exporting a `default` property:

```javascript
module.exports = {
  __esModule: true,
  default: () => 'View',
};
```

You can use the same techniques with `jest.mock` too, in your test file, to mock case-by-case. In your test file:

```typescript
jest.mock('react-native-stager', () => ({
  __esModule: true,
  Stage: 'View',
  StageButtons: 'View',
  StageProgress: 'View',
  default: 'View',
}));

describe('components', () => {
...
```

This also works for relative imports i.e your own codebase.

### Mock once

We can mock per-case basis by resetting modules between runs and writing inline mocks.

Do _NOT_ import using ES6 syntax before mocking.

```typescript
describe('MOCK ONCE', () => {
   beforeEach(() => {
    jest.resetModules();
  });

it('when nav state `Menu` color is `waiting`', () => {
  jest.mock('@react-navigation/native', () => ({
    useNavigationState: () => 'Menu',
    useNavigation: () => {},
  }));
  jest.mock('./UseOrders', () => ({
    UseOrders: () => ({
      busy: false,
      error: undefined,
      empty: false,
      itemsWithKey: [{status: 'ondelivery'}],
    }),
  }));

  // Dynamic import for mock to apply
  const OrderFab = require('./OrderFab').default;
  const {getById} = render(OrderFab);
  ...
```
